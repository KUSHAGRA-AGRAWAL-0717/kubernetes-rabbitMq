notification/
├── consumer.py
│   # CODE:
│   import pika, sys, os, time
│   from send import email
│   
│   def main():
│       # rabbitmq connection
│       connection = pika.BlockingConnection(pika.ConnectionParameters(host="rabbitmq"))
│       channel = connection.channel()
│   
│       def callback(ch, method, properties, body):
│           err = email.notification(body)
│           if err:
│               ch.basic_nack(delivery_tag=method.delivery_tag)
│           else:
│               ch.basic_ack(delivery_tag=method.delivery_tag)
│   
│       channel.basic_consume(
│           queue=os.environ.get("MP3_QUEUE"), on_message_callback=callback
│       )
│   
│       print("Waiting for messages. To exit press CTRL+C")
│   
│       channel.start_consuming()
│   
│   if __name__ == "__main__":
│       try:
│           main()
│       except KeyboardInterrupt:
│           print("Interrupted")
│           try:
│               sys.exit(0)
│           except SystemExit:
│               os._exit(0)
├── Dockerfile
│   # CODE:
│   FROM python:3.10-slim-bullseye
│   
│   RUN apt-get update \
│     && apt-get install -y --no-install-recommends --no-install-suggests \
│     build-essential \
│     && pip install --no-cache-dir --upgrade pip
│   
│   WORKDIR /app
│   COPY ./requirements.txt /app
│   RUN pip install --no-cache-dir --requirement /app/requirements.txt
│   COPY . /app
│   
│   CMD ["python3", "consumer.py"]
├── requirements.txt
│   # CODE:
│   astroid==2.9.3
│   isort==5.10.1
│   jedi==0.18.1
│   lazy-object-proxy==1.7.1
│   mccabe==0.6.1
│   parso==0.8.3
│   pika==1.2.0
│   platformdirs==2.5.1
│   pylint==2.12.2
│   toml==0.10.2
│   wrapt==1.13.3
├── manifests/
│   ├── configmap.yaml
│   │   # CODE:
│   │   apiVersion: v1
│   │   kind: ConfigMap
│   │   metadata:
│   │     name: notification-configmap
│   │   data:
│   │     MP3_QUEUE: "mp3"
│   │     VIDEO_QUEUE: "video"
│   ├── notification-deploy.yaml
│   │   # CODE:
│   │   apiVersion: apps/v1
│   │   kind: Deployment
│   │   metadata:
│   │     name: notification
│   │     labels:
│   │       app: notification
│   │   spec:
│   │     replicas: 4
│   │     selector:
│   │       matchLabels:
│   │         app: notification
│   │     strategy:
│   │       type: RollingUpdate
│   │       rollingUpdate:
│   │         maxSurge: 8
│   │     template:
│   │       metadata:
│   │         labels:
│   │           app: notification
│   │       spec:
│   │         containers:
│   │           - name: notification
│   │             image: kushagra0717/notification
│   │             envFrom:
│   │               - configMapRef:
│   │                   name: notification-configmap
│   │               - secretRef:
│   │                   name: notification-secret
│   ├── secret.yaml
│   │   # CODE:
│   │   apiVersion: v1
│   │   kind: Secret
│   │   metadata:
│   │     name: notification-secret
│   │   stringData:
│   │     GMAIL_ADDRESS: "videompconvertermessage@gmail.com"
│   │     GMAIL_PASSWORD: "VideoMp3@2020"
│   │   type: Opaque
├── send/
│   ├── __init__.py
│   │   # CODE:
│   │   (empty file)
│   ├── email.py
│   │   # CODE:
│   │   import smtplib, os, json
│   │   from email.message import EmailMessage
│   │   
│   │   def notification(message):
│   │       # try:
│   │       message = json.loads(message)
│   │       mp3_fid = message["mp3_fid"]
│   │       sender_address = os.environ.get("GMAIL_ADDRESS")
│   │       sender_password = os.environ.get("GMAIL_PASSWORD")
│   │       receiver_address = message["username"]
│   │   
│   │       msg = EmailMessage()
│   │       msg.set_content(f"mp3 file_id: {mp3_fid} is now ready!")
│   │       msg["Subject"] = "MP3 Download"
│   │       msg["From"] = sender_address
│   │       msg["To"] = receiver_address
│   │   
│   │       session = smtplib.SMTP("smtp.gmail.com", 587)
│   │       session.starttls()
│   │       session.login(sender_address, sender_password)
│   │       session.send_message(msg, sender_address, receiver_address)
│   │       session.quit()
│   │       print("Mail Sent")
│   │   
│   │   # except Exception as err:
│   │   # print(err)
│   │   # return err
